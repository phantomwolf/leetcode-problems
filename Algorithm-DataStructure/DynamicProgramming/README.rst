动态规划
===============================
动态规划是一种算法范式(algorithmic paradigm)，它将复杂的问题分解为较小的子问题，并且存储这些子问题解，以避免重复求解。


性质
-------------------------
以下两个性质确保问题可以用动态规划解决：

重叠子问题
++++++++++++++++++++
像分治法一样，动态规划需要合并子问题的解。动态规划多用于需要重复计算子问题的解的情况，它将子问题的解存入一个数组，之后需要时直接读取，提高了性能。

所以当子问题不需要重复求解时(例如归并排序)，动态规划是没有意义的，因为不需要存储子问题的解。

最优子结构
++++++++++++++++++++
一个问题拥有最优子结构(Optimal substructure)，说明问题可以通过采用其子问题的最优解来解决。


问题
-------------------------
LIS
++++++++++++++++++++
Longest Increasing Subsequence：在一个序列（比如一个数组）中，找出最长的子序列的长度，使其所有元素递增。子序列不要求连续。

状态转移方程：设d[i]为在i处结尾的最长递增子序列的长度。那么有::

    设0 < j < i，若存在arr[j] < arr[i]，那么d[i] = 1 + max(d[j])
                 若不存在这样的j，那么d[i] = 1

可见，我们必须把所有的j尝试一遍，才能知道d[i]的值。要求出d[3]，我们需要求出d[2]、d[1]、d[0]；要求出d[2]，我们需要求出d[1]、d[0]。如果我们用普通的递归法求解，d[1]、d[0]会被重复求值。因此我们用循环的方式，先求较小问题，并用数组d存储它们的结果，避免重复求解。

LCS
++++++++++++++++++++
描述：Longest Common Subsequence：给定2个序列，找出它们最长的公共子序列，求其长度。子序列不要求连续。LCS可用于表示两个字符串的相似度

Edit Distance
++++++++++++++++++++
给定2个字符串str1和str2，str1上可以执行插入一个字符、删除一个字符、替换一个字符这3个操作。问至少需要多少次操作，可以把str1转换为str2。

定义子问题：设str1长度为m，str2长度为n。子问题就是求str1与str2的前缀的edit distance。

递归解
~~~~~~~~~~~~~~
设edit_distance(str1, m, str2, n)为str1与str2的edit distance。

如果str1和str2的最后一个字符相同，那么我们就没必要对这个字符进行任何操作，因此可以将问题转化为一个较小的问题edit_distance(str1, m - 1, str2, n - 1)。

如果str1和str2的最后一个字符不相同，那我们有3种操作可以选，我们需要求操作数最少的一个::

    edit_distance(str1, m, str2, n) == 1 + min(edit_distance(str1, m, str2, n - 1), // 插入
                                               edit_distance(str1, m - 1, str2, n), // 删除
                                               edit_distance(str1, m - 1, str2, n - 1)) // 替换

Min Cost Path
++++++++++++++++++++
给定一个代价矩阵，矩阵中每个元素都表示经过该位置的代价。给定其中一个位置(m, n)，求从(0, 0)到达(m, n)所需的最小代价，以及路线。只能向右、向下或对角线前进::

    1 → 2   3
          ↘
    4   8   2
            ↓
    1   5   3

最优子结构
~~~~~~~~~~~~~~
要到达(m, n)，必须要经过3个位置中的1个：(m-1, n-1), (m-1, n), (m, n-1)。所以到达(m, n)的最小代价，等于到达这3个位置中代价的最小值，加上(m, n)的代价。由此，问题转化为子问题的最优解。

重叠子问题
~~~~~~~~~~~~~~
设min_cost(m, n)为到达(m, n)的最小代价，cost为代价矩阵，那么递归解为::

    min_cost(m, n) = cost[m][n] + min(min_cost(m - 1, n - 1),
                                      min_cost(m - 1, n),
                                      min_cost(m, n - 1));

                                    mC(2, 2)
                          /            |           \
                         /             |            \             
                 mC(1, 1)           mC(1, 2)             mC(2, 1)
              /     |     \       /     |     \           /     |     \ 
             /      |      \     /      |      \         /      |       \
       mC(0,0) mC(0,1) mC(1,0) mC(0,1) mC(0,2) mC(1,1) mC(1,0) mC(1,1) mC(2,0) 

可见，有些结点的代价被重复计算。如果问题的规模扩大，重复的结点会更多。因此，我们可以使用动态规划。

Coin Change
++++++++++++++++++++
有数量不限的面值为S = {S1, S2, .., Sm}的硬币，要凑齐N元，有多少种方案。

分析
~~~~~~~~~~~~~~
与求凑齐N元所需的最少硬币数不同，本题求共有多少种方案(且不能重复)。

本题并不能简单的用count(i)表示凑齐i元所需的方案数：假设有充足的面值为1、2的两种硬币，需要凑齐3元，有以下几种方案::

    先凑齐2元，再拿一个1元硬币
    先凑齐1元，再拿一个2元硬币

要凑齐2元，也有两种方案::

    两个1元硬币
    一个2元硬币

表面上看，凑齐3元共有3种方案：{1, 1, 1}, {1, 2}, {2, 1}。然而有2种方案是重复的。

为了避免重复，我们定义count(m, n)为只使用coins[0..m]种硬币，凑齐n元有多少种方案(相当于排除了一些硬币coins[m+1..$])。要凑齐n元，有两类方案：一种是完全不包含coins[m]的；一种是至少包含一个coins[m]的。因此::

    count(m, n) = count(m - 1, n) + count(m, n - coins[m])

设d[i][j]为，在可以使用coins[0..j]的情况下，凑齐i元，共有多少种方案。于是有::

    int d[amount + 1][coins.size()];
    for (int i = 0; i < len; ++i) {
        // 要凑齐0元，不管用哪些硬币，都只有1种方案
        d[0][i] = 1;
    }

    for (int i = 1; i <= amount; ++i) {
        for (int j = 0; j < len; ++j) {
            int x = (j > 0) ? d[i][j - 1] : 0;
            int y = (i >= coins[j]) ? d[i - coins[j]][j] : 0;
            d[i][j] = x + y;
        }
    }

但是此算法的空间可以进一步优化。已知count(0, n) = 0，将cout(m, n)的式子继续展开，有::

    count(m,n) = count(m-1,n) + count(m,n-coins[m])
               = count(m-2,n) + count(m-1,n-coins[m-1]) + count(m,n-coins[m])
               = count(m-3,n) + count(m-2,n-coins[m-2]) + count(m-1,n-coins[m-1]) + count(m,n-coins[m])
               ...
               = count(0,n) + count(1,n-coins[1]) + count(2, n-coins[2]) + ... + count(m,n-coins[m])
               = count(1,n-coins[1]) + count(2, n-coins[2]) + ... + count(m,n-coins[m])

即不断缩小可选硬币的范围，每次都规定至少使用一个可用范围内最大面值的硬币。通过更改循环的次序，我们可以用一维数组来解决问题::

    int d[amount + 1] = {0};
    d[0] = 1;
    for (int i = 0; i < len; ++i) {
        for (int j = coins[i]; j <= amount; ++j)
            d[j] += d[j - coins[i]];

i为coins的下标，表示至少要使用一个coins[i]硬币；j为要凑齐的钱数。如果j < coins[i]，显然可行方案数为0（默认值），因此j是从本次必须要使用的硬币面值coins[i]开始增长的。


矩阵相乘
++++++++++++++++++++
有一系列矩阵相乘，求相乘的顺序，使得乘法运算的次数最少。返回最少的乘法次数。

矩阵乘法的次序不影响最终结果，例如(AB)C = A(BC)。设3个矩阵，分别为：A 10x30，B 30x5, C 5x60。两种计算次序的乘法次数分别为::

    (AB)C = (10x30x5) + (10x5x60) = 4500
    A(BC) = (30x5x60) + (10x30x60) = 27000

可见第一种方法更加高效。
