哈系表、记录访问过的结点
==================================
时间复杂度：O(n)；空间复杂度：O(n)

Visited nodes法。遍历链表，用哈系表或其他数据结构，记录已经访问过的结点。如果在遍历中遇到一个已访问过的结点，那就说明存在一个环，这个已访问过的结点就是环的开始。


Floyd判圈算法
==================================
判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)或者快慢指针算法（Slow and Fast Pointers Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。

初始状态下，假设已知某个起点节点为节点S。现设两个指针slow和fast，将它们均指向S。

接着，同时让slow和fast往前推进，但是二者的速度不同：slow每前进1步，fast前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当fast无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当slow与fast再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。(这是因为如果存在环，fast会一直在环里打转，直到与slow相遇)

环的长度
-------------------
如果确定了存在某个环，就可以求此环的起点与长度。上述算法刚判断出存在环C时，显然slow和fast位于同一节点，设其为节点M。显然，仅需令fast不动，而slow不断推进，最终又会返回节点M，统计这一次slow推进的步数，显然这就是环C的长度。

环的起始点
-------------------
有两种方法。第一种方法，先用上述方法求出环的长度N，然后令slow = head，令fast = slow + N。令两个指针按照同样的速度前进，由于fast比slow靠前N个位置（环的长度），所以fast会比slow先进入环，然后在环中绕一圈，最后与slow在环的起始点相遇。

第二种方法，不需要先计算环的长度N。我们只需令slow从链表头部出发，fast从相遇点出发，按照相同的速度前进，两者就会在环的起始点相遇。为什么会这样呢？原理如下：

当slow与fast相遇时，情况如下图：

.. image:: LinkedListCycle.jpg

m为从链表开头到环的起始点的距离；n为环的长度；k为slow和fast的相遇点与环起始点的距离。我们知道，fast每次前进2个位置，slow每次前进1个位置，所以::

	fast经过的距离 = 2 * slow经过的距离

设两者相遇时，fast在环里转了x圈，slow在环里转了y圈，有::

	m + x*n + k = 2 * (m + y*n + k)

即::

	m + k = (x - 2y) * n	=>	m = (x - 2y) * n - k

即m + k为n的整数倍。我们让slow从链表头部开始，fast依然从相遇点开始，两者以相同的速度前进。因为fast距离环的起始点已经有k的距离，所以根据以上方程，当fast绕了若干圈恰巧走到环的起始点时，slow与fast刚好会相遇。于是我们就得到了环的起始点。如果设置一个变量end来保存fast的前一个值，我们就能得到环的结束点。
